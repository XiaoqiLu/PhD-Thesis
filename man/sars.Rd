% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/base.R
\name{sars}
\alias{sars}
\title{SARS Object}
\usage{
sars(states, actions, rewards, states_next)
}
\arguments{
\item{states}{a numeric matrix for states, each row for each time step.}

\item{actions}{a numeric matrix for actions.}

\item{rewards}{a numeric column vector for rewards.}

\item{states_next}{a numeric matrix for next states.}
}
\value{
a SARS object (\code{class = "sars"})
}
\description{
The function \code{sars()} creates a SARS object for discrete-time Markov Decision
Process (MDP) data.
}
\details{
SARS stands for \eqn{S} (state), \eqn{A} (action), \eqn{A} (reward), and
\eqn{S'} (next state), a basic unit of MDP.

SARS objects are designed to store more than one units. A typical use case is
MDP trajectories of the form
\deqn{S_1, A_1, R_1, S_2, A_2, R_2, \ldots, S_n, A_n, R_n, S_{n+1}}
which can be rearranged into units \eqn{(S_1, A_1, R_1, S'_1=S_2)}, \eqn{(S_2, A_2, R_2, S'_2=S_3)},
and so on. Elements across all units are then stacked together into matrices of
\code{states}, \code{actions}, \code{rewards}, and \code{states_next}. For example, if each \eqn{S}
is a \eqn{p}-vector, then \code{state} is a \eqn{n}-by-\eqn{p} matrix.

This structure is not a compact representation for trajectory use-case, because
\code{states_next} would be a duplicate for 1 time step lagged \code{states}. However,
it has compatibility over more than one trajectories: simply stacking matrices
from different trajectories together. This single-matrix representation provides
some computational advantages.
}
\note{
For 1D arguments (e.g. reward as a real number), a column vector (\eqn{n}-by-\eqn{1} matrix)
is expected.
}
\examples{
states <- matrix(c(1, 2, 3, 4), 2, 2)
actions <- matrix(c(1, 0), 2, 1)
rewards <- matrix(c(1, 2), 2, 1)
states_next <- matrix(c(2, 3, 4, 5), 2, 2)
ss <- sars(states, actions, rewards, states_next)
ss
}
